---
title: "Keep it simple - Transient object"
layout: post
date: 2018-06-17
categories: tip patterns cross-platform code-snippet net.core c#
---

# Introduction

First of a series of article with small tip on OOP programming can give you the instrument to write less & better code.

## Problem

In a standard OOP program there are fondamentally three types of life-cycle in object a run-time:

* Singleton - Object who lives for entire time who lives the process (eg. Service)
* Per-Scope - Object who lives in a defined (and timed) scope (eg. Request in a REST service)
* Transient - Object who lives the time needed for implementing an operation (eg. Unit of Work)

## How to keep simple

The container is a service wich contain object and manage trought a factory their lifetime, most known factory library support the concept of transient object, other framework simply not implement this pattern by design.

There are no any reasons (expect particular cases thath I don't remember now) to register and instantiate transient object using an object factory: this practice introduce an useless overhead and/or a level of indirection (specially when the transient object is registered by type requiring the factory to use the reflection to instantiate it...).

## Some example

```csharp
class UnitOfWork : IDisposable
{
    public static int InstanceCount { get; private set; } //Using for testing

    public UnitOfWork()
    {
        InstanceCount++; //Only for debug assert here we don't care about concurrency
    }

    public void Dispose()
    {
        InstanceCount--; //Only for debug assert here we don't care about concurrency
    }
}
```

### Standard instantiation

```csharp
using (new UnitOfWork())
{
    //Some work & commit
}
```

Test results (single thread)

```
Total time 2381 ms; Repetition 100.000.000; Speed 41.999 operation/ms
Total time 2504 ms; Repetition 100.000.000; Speed 39.936 operation/ms
Total time 2448 ms; Repetition 100.000.000; Speed 40.849 operation/ms
Total time 2494 ms; Repetition 100.000.000; Speed 40.096 operation/ms
Total time 2469 ms; Repetition 100.000.000; Speed 40.502 operation/ms
Total time 2457 ms; Repetition 100.000.000; Speed 40.700 operation/ms
Total time 2450 ms; Repetition 100.000.000; Speed 40.816 operation/ms
Total time 2465 ms; Repetition 100.000.000; Speed 40.567 operation/ms
Total time 2499 ms; Repetition 100.000.000; Speed 40.016 operation/ms
Total time 2366 ms; Repetition 100.000.000; Speed 42.265 operation/ms
Average times 2453 ms; Standard deviation 47 ms
```

#### Result analysis

Average times 2453 ms to instatiante and dispose 100 milion of object with a standard deviation indicates more deterministic results

using Microsoft.Extensions.DependencyInjection (.NET Core 2.1)

```csharp
//Initialization

var serviceCollection = new ServiceCollection();
serviceCollection.AddTransient<UnitOfWork>();
ServiceProvider serviceProvider = serviceCollection.BuildServiceProvider();

//Utilization
using ((UnitOfWork)serviceProvider.GetService(typeof(UnitOfWork)))
{
    //Some work & commit
}
```

Test results (single thread)

```
Total time 13593 ms; Repetition 100.000.000; Speed 7.356 operation/ms
Total time 13022 ms; Repetition 100.000.000; Speed 7.679 operation/ms
Total time 16630 ms; Repetition 100.000.000; Speed 6.013 operation/ms
Total time 11693 ms; Repetition 100.000.000; Speed 8.552 operation/ms
Total time 14373 ms; Repetition 100.000.000; Speed 6.957 operation/ms
Total time 14593 ms; Repetition 100.000.000; Speed 6.852 operation/ms
Total time 26972 ms; Repetition 100.000.000; Speed 3.707 operation/ms
Total time 38055 ms; Repetition 100.000.000; Speed 2.627 operation/ms
Total time 12571 ms; Repetition 100.000.000; Speed 7.954 operation/ms
Total time 12135 ms; Repetition 100.000.000; Speed 8.240 operation/ms
Average times 17364 ms; Standard deviation 8519 ms
```
#### Result analysis

Average times 17364 ms to instatiante and dispose 100 milion of object (700%+ time consuming) with a standard deviation indicates lesse deterministic results

## Conclusion

Creating a multiplatform software is a great idea, but do not think that the simple transition to .NET Core will not be painless.
Correct unit test e/o integration e/o smoke e/o human UAT it will be better to plan it as contingency before thinking to a migration.
Also, Docker seems to be a very powerful & lightweight alternative to software virtualization.
