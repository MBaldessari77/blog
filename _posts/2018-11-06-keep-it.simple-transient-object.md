---
title: "Keep it simple - Transient object"
layout: post
date: 2018-06-17
categories: tip patterns cross-platform code-snippet net.core c#
---

# Introduction

First of a series of article with small tip on OOP programming can give you the instrument to write less & better code.

## Problem

In a standard OOP program there are fondamentally three types of life-cycle in object a run-time:

* Singleton - Object who lives for entire time who lives the process (eg. Service)
* Per-Scope - Object who lives in a defined (and timed) scope (eg. Request in a REST service)
* Transient - Object who lives the time needed for implementing an operation (eg. unit-of-work)

## How to keep simple

The container is a service wich contain object and manage trought a factory their lifetime, most known factory library support the concept of transient object, other framework simply not implement this pattern by design.

There are no any reasons (expect particular cases thath I don't remember now) to register and instantiate transient object using an object factory: this practice introduce an useless overhead and/or a level of indirection (specially when the transient object is registered by type requiring the factory to use the reflection to instantiate it...).

## Some example

```csharp
class UnitOfWork : IDisposable
{
    public static int InstanceCount { get; private set; } //Using for testing

    public UnitOfWork()
    {
        InstanceCount++; //Only for debug assert we don't care about concurrency
    }

    public void Dispose()
    {
        InstanceCount--; //Only for debug assert we don't care about concurrency
    }
}
```

### Standard instantiation

```csharp
using (new UnitOfWork())
{
    //Some work & commit
}
```

Test results (single thread)

```
Total time 2381 ms; Repetition 100.000.000; Speed 41.999 operation/ms
Total time 2504 ms; Repetition 100.000.000; Speed 39.936 operation/ms
Total time 2448 ms; Repetition 100.000.000; Speed 40.849 operation/ms
Total time 2494 ms; Repetition 100.000.000; Speed 40.096 operation/ms
Total time 2469 ms; Repetition 100.000.000; Speed 40.502 operation/ms
Total time 2457 ms; Repetition 100.000.000; Speed 40.700 operation/ms
Total time 2450 ms; Repetition 100.000.000; Speed 40.816 operation/ms
Total time 2465 ms; Repetition 100.000.000; Speed 40.567 operation/ms
Total time 2499 ms; Repetition 100.000.000; Speed 40.016 operation/ms
Total time 2366 ms; Repetition 100.000.000; Speed 42.265 operation/ms
Average times 2453 ms; Standard deviation 47 ms
```

using Microsoft.Extensions.DependencyInjection (.NET Core 2.1)

```csharp
//Initialization

var serviceCollection = new ServiceCollection();
serviceCollection.AddTransient<UnitOfWork>();
ServiceProvider serviceProvider = serviceCollection.BuildServiceProvider();

//Utilization
using ((UnitOfWork)serviceProvider.GetService(typeof(UnitOfWork)))
{
    //Some work & commit
}
```

Test results (single thread)

```
Total time 13454 ms; Repetition 100.000.000; Speed 7.432 operation/ms
Total time 13218 ms; Repetition 100.000.000; Speed 7.565 operation/ms
Total time 16913 ms; Repetition 100.000.000; Speed 5.912 operation/ms
Total time 11809 ms; Repetition 100.000.000; Speed 8.468 operation/ms
Total time 13985 ms; Repetition 100.000.000; Speed 7.150 operation/ms
Total time 39761 ms; Repetition 100.000.000; Speed 2.515 operation/ms
Total time 19609 ms; Repetition 100.000.000; Speed 5.099 operation/ms
Total time 36759 ms; Repetition 100.000.000; Speed 2.720 operation/ms
Total time 52801 ms; Repetition 100.000.000; Speed 1.893 operation/ms
Total time 58875 ms; Repetition 100.000.000; Speed 1.698 operation/ms
Average times 27718 ms; Standard deviation 17841 ms
```

## Conclusion

Creating a multiplatform software is a great idea, but do not think that the simple transition to .NET Core will not be painless.
Correct unit test e/o integration e/o smoke e/o human UAT it will be better to plan it as contingency before thinking to a migration.
Also, Docker seems to be a very powerful & lightweight alternative to software virtualization.
